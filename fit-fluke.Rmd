---
title: "R Notebook"
output: html_document
---
# Packages


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r packages}
set.seed(42)
library(tidyverse)
library(tidybayes)
library(Cairo)
library(here)
library(magrittr)
library(rstan)
library(Matrix)
library(ggridges)
# library(rstanarm)
```
## Get summer flounder data

Note that we are now pulling in the raw length composition data, and it is for the fall survey only.

```{r data}
rawdat <- read_csv(here("processed-data","fluke_catch_at_length_fall.csv"))
```

## Convert to ages 


Page 58 of SAW 66: In the current work, the NEFSC trawl survey data for 1976-2016 (ages for 2017 were not yet available) were used to estimate growth parameters for males, females, and sexes combined for the full time series and for seven multi-year (generally five year) bins. The full time series data provide parameters for males (n = 19,424) of Linf = 63.9 cm, k = 0.18, with maximum length of 67 cm (age 6) and age of 15 (length 56-57 cm); parameters for females (n = 20,689) of Linf = 80.6 cm, k = 0.18, with maximum length of 82 cm (age 11) and age of 14 (length 76 cm); and **parameters for sexes combined (n = 40,942, including small fish of undetermined sex) of Linf = 83.6, k = 0.14, with maximum age of 15** (Table below, Figure A66).

AF note: not sure how max age should be used

```{r length-age}
Loo = 83.6
k = 0.14

get_age_from_length <- function(length){
  age = log(1-length/Loo)/-k # Dan, can you confirm I did this right? 
  return(age)
}

rawdat$age <- get_age_from_length(rawdat$length)

hist(rawdat$age)

agedat <- rawdat %>% 
  filter(year>=1972) %>% 
  mutate(age_ceil = ceiling(age), # rounding up so we don't have age zero - should start at age 1
         lat_floor = floor(lat)) %>% 
  rowwise() %>% 
  mutate(
         age_ceil = min(age_ceil, 15)  # this is estimating a small number of super old fish, up to 24 -- I'm reclassifying them as 15 for now based on the stock assessment, is that right?
         ) %>% 
  group_by(year, age_ceil, lat_floor) %>% 
  summarise(number_at_age = sum(number_at_length)) %>% 
  ungroup()

# visualize lat band sampling in fall 

lat_pres <- agedat %>% 
  select(lat_floor, year) %>% 
  distinct() %>% 
  mutate(surveyed=TRUE)

expand.grid(year=unique(agedat$year), lat_floor=unique(agedat$lat_floor)) %>% # get all possible band*year combos
  left_join(agedat %>% # get df with just surveyed bands
  select(lat_floor, year) %>% 
  distinct() %>% 
  mutate(surveyed=TRUE)
  ) %>% 
  mutate(surveyed=replace_na(surveyed, FALSE)) %>%  #classify unsurveyed rows as false
  ggplot(aes(x=year, y=lat_floor)) +
  geom_tile(aes(fill=surveyed)) +
  scale_y_continuous(breaks=seq(min(agedat$lat_floor), max(agedat$lat_floor, 1)))
# based on this, let's drop lat bands below 35 and the year 2016

agedat %<>% filter(lat_floor>34, year<2016)

# check that this now means all bands are surveyed in all years 
expand.grid(year=unique(agedat$year), lat_floor=unique(agedat$lat_floor)) %>% # get all possible band*year combos
  left_join(agedat %>% # get df with just surveyed bands
  select(lat_floor, year) %>% 
  distinct() %>% 
  mutate(surveyed=TRUE)
  ) %>% 
  mutate(surveyed=replace_na(surveyed, FALSE)) %>%  #classify unsurveyed rows as false
  ggplot(aes(x=year, y=lat_floor)) +
  geom_tile(aes(fill=surveyed)) +
  scale_y_continuous(breaks=seq(min(agedat$lat_floor), max(agedat$lat_floor, 1)))
```

## Prep for model

```{r modelprep}
## get time dimension
years <- sort(unique(agedat$year)) 
ny <- length(years)
years_train <- ny-10
years_proj <- 10

#get other dimensions
patches <- sort(unique(agedat$lat_floor))
np = length(patches) 
ages <- sort(unique(agedat$age_ceil))
na <- length(ages) 

# make temperature matrix
sbtdat <- rawdat %>% 
  mutate(lat_floor = floor(lat)) %>% 
  filter(lat_floor %in% unique(agedat$lat_floor),
         year %in% unique(agedat$year)) %>% # only use lat bands in the trimmed age data
  group_by(lat_floor, year) %>% 
  summarise(sbt=mean(btemp, na.rm=TRUE)) %>% 
  ungroup() %>% 
  mutate(patch= as.integer(as.factor(lat_floor)), 
         year=as.integer(as.factor(year))) %>% #change real values to indices
  select(-lat_floor)

sbt <- as.matrix(with(sbtdat, sparseMatrix(patch, year, x=sbt))) # visually inspect this to be sure there are no zeroes -- they occur early in the time-series and also in 2016, but the data trimming should have taken care of it

# make population matrix

# add indices
agedat$patch <- as.integer(as.factor(agedat$lat_floor))
agedat$year <- as.integer(as.factor(agedat$year))

# fill in matrix
pop <- array(NA, dim = c(np, na, ny)) 
for(p in 1:np){
  for(a in 1:na){
    for(y in 1:ny){
      tmp <- agedat %>% filter(patch==p, age_ceil==a, year==y)
      pop[p,a,y] <- tmp$number_at_age
    }
  }
}

# mortality
m = 0.25
f = 0.334
z = exp(-m-f)

#spillover
spill=0.1
```

## fit a model

# HERE BEGINS DAN'S OLD CODE

explore data 

```{r explore-data}


  flukepop %>% 
  group_by(patch) %>% 
  mutate(scount = count / max(count)) %>% 
  ungroup() %>% 
    # filter(year > 40, patch == 4) %>% 
  ggplot(aes(stage,scount, fill = factor(patch))) + 
  geom_col(position = "dodge") + 
    facet_wrap(~year)


flukepop %>% 
  group_by(stage) %>% 
  summarise(missing = mean(count == 0))

flukepop %>% 
  group_by(year,patch) %>% 
  summarise(hmm = (count[stage ==3] == 0 & sum(count) > 0))
  
```
# New Model Idea

Use stage 3 to scale the population, fir to the absolute numbers in 3, and back out the recruits. 

Two if statements, if there are any stage comps, and if there are any stage 3s

Let's keep it simple and say that if no stage 3 individuals are observed, nothing is observed, to avoid a weird edge case where some fish are seen, but no stage 3 are seen. Will need to revist this as the data change

So what's the observation model? Probably something like temperature plus a patch fixed effect

```{r}
a <- flukepop %>% 
  group_by(year, patch) %>% 
  summarise(seen = count[stage == 3] > 0,
            numbers = sum(count))

sbt_frame <- sbt %>% 
  as.data.frame() %>% 
  mutate(patch = 1:nrow(.)) %>% 
  pivot_longer(-patch, names_to = "year", values_to = "sbt", names_prefix = "V") %>% 
  mutate(year = as.integer(year))

a <- a %>% 
  left_join(sbt_frame, by = c("year","patch")) %>% 
  group_by(patch) %>% 
  mutate(centered_numbers = numbers - mean(numbers)) %>% 
  group_by(patch) %>% 
  arrange(patch,year) %>% 
  mutate(delta_sbt = sbt - lag(sbt,2),
         delta_numbers = numbers - lag(numbers,1))

mean(a$seen)

a %>% 
  ggplot(aes(sbt, numbers)) + 
  geom_point()

a %>% 
  ggplot(aes(sbt, centered_numbers)) + 
  geom_point()

a %>% 
  ggplot(aes(delta_sbt, delta_numbers)) + 
  geom_point() + 
  scale_x_continuous(name = "Change in SBT") +
  scale_y_continuous(name = "Change in Numbers")

a %>% 
  ggplot(aes(sbt, fill = factor(patch))) + 
  geom_density(alpha = 0.25)

seen_model <- stan_glm(seen ~ sbt, data = a, family = "binomial") # should have patch as well, but let's keep it simple for now, seems to work well enough
# rstanarm::launch_shinystan(seen_model)
summary(seen_model)
plot(seen_model)

rstanarm::posterior_vs_prior(seen_model)


```


At the moment modeling recruit as temperature driven deviations from mean recruitment. Looking at the patches, I don't think that makes much sense. Let's instead make temperature alter mean recruitment itself, and then allow deviation away from that. 

So, lets say that

$$\bar{r}_{p,y} = Re^{f(t_{p,y})} $$

and then

$$r_{p,y} \sim normal(log(\bar{r}_{p,y}),\sigma_r)$$

So, let's say presence / absence of stage 3 individuals is

$$seen_{p,y} \sim bernoulli(1 + sst_{p,y})$$

If anything is seen...

$$1 \sim bernoulli(1 + sst_{p,y})$$

$$n_{s=3,p,y} \sim NB(\hat{n_{s=3,p,y}} \times sel_{s = 3},\phi) $$

$$pn_{p,y} \sim multinomial(\hat{pn_{p,y} \times sel})$$

else

$$0 \sim bernoulli(1 + sst_{p,y})$$



```{r fit T_dep_rec}

stage_data <- list(
  sel_at_stage = sel_at_stage,
  sst = sbt[, 1:years_train], # this isn't SST anymore, it's SBT... need to rename in model
  sst_proj = sbt[, (years_train):ny],
  spill = spill,
  np = np,
  ns = ns,
  ny = years_train,
  n_p_s_y = pop[,,1:years_train],
  proj_init = pop[,,years_train],
  mean_length_at_age = 1:ns,
  ny_proj = years_proj + 1, 
  m = z,  # should rename model to Z at some point?
  g = g
)

warmups <- 2000

total_iterations <- 4000

max_treedepth <-  12

n_chains <-  4

n_cores <- 4 

stage_model_fit <- stan(file = here::here("src","T_dep_rec_fluke.stan"), # check that it's the right model!
           data = stage_data,
           chains = 4,
           warmup = warmups,
           iter = total_iterations,
           cores = 4,
           refresh = 250,
           control = list(max_treedepth = max_treedepth,
                          adapt_delta = 0.95)
           )

```

Process results
```{r}

n_p_s_y_hat <-  tidybayes::gather_draws(stage_model_fit, n_p_s_y_hat[patch, stage,year], n = 1000)

n_p_s_y <- pop[,,1:years_train] %>% 
  reshape::melt(varnames = c("patch","stage","year")) %>% 
  as_tibble() 

sel <- tibble(stage = 1:ns, sel = sel_at_stage)

gg_n_p_s_y_hat <- n_p_s_y_hat %>% 
  left_join(sel, by = "stage") %>% 
  ggplot() +
  stat_lineribbon(aes(x = year, y = .value * sel, group=stage),.width = c(.99, .95, .8, .5), color = "red") +
  geom_point(data = n_p_s_y, aes(x=year, y=value, group=stage), size = 2,alpha = 0.5) + 
  facet_grid(patch~stage, scales = "free_y") + 
  scale_fill_brewer() +
  labs(title="model predictions")

gg_n_p_s_y_hat
gg_n_p_s_y_hat_s3 <- n_p_s_y_hat %>% 
  left_join(sel, by = "stage") %>% 
  filter(stage == 3) %>% 
  ggplot() +
  stat_lineribbon(aes(x = year, y = .value * sel, group=stage),.width = c(.99, .95, .8, .5), color = "red") +
  geom_point(data = n_p_s_y %>% filter(stage == 3), aes(x=year, y=value, group=stage), size = 2,alpha = 0.5) + 
  facet_wrap(~patch) + 
  scale_fill_brewer() +
  labs(title="model predictions")

gg_n_p_s_y_hat_s3
```


```{r}


pp_proj_n_p_s_y_hat <-  tidybayes::gather_draws(stage_model_fit, pp_proj_n_p_s_y_hat[patch, stage,year], n = 1000)

n_p_s_y_proj <- pop[,,(years_train):ny] %>% 
  reshape::melt(varnames = c("patch","stage","year")) %>% 
  as_tibble() 


gg_pp_proj_n_p_s_y_hat <- pp_proj_n_p_s_y_hat %>% 
  filter(stage == 3) %>% 
  ggplot() +
  stat_lineribbon(aes(x = year, y = .value, group=stage),.width = c(.99, .95, .8, .5), color = "red") +
  geom_point(data = n_p_s_y_proj %>% filter(stage == 3), aes(x=year, y=value, group=stage), size = 2,alpha = 0.5) + 
  facet_wrap(~patch, scales = "free_y") + 
  scale_fill_brewer() +
  labs(title="forecast")

gg_pp_proj_n_p_s_y_hat
```

