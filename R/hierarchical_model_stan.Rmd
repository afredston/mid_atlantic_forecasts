---
title: "Dynamic range model in Stan"
author: "Alexa Fredston and Malin Pinsky"
date: "begun November 2020"
output: html_document
---

## General notes

Useful sources for Bayesian population models and Bayesian implementation in R that we referenced while building this script: 

* https://github.com/DanOvando/learn-stan 
* https://arxiv.org/src/2002.02001v1/anc/Appendix_S1.pdf p. 72
* https://cchecastaldo.github.io/BayesianShortCourse/Syllabus.html
* https://mc-stan.org/docs/2_25/stan-users-guide/mark-recapture-models.html 

## Model notes

* Stan can't estimate discrete latent variables, so we've moved N from being discrete to continuous

## To-do

* Revisit choices of initial values
* Add random Poisson noise around estimates of N every year (took this out to ensure Stan model was working correctly)
* Move away from uniform priors

```{r packages}
library(rstan)
library(rstanarm)
library(tidybayes)
library(bayesplot)
```


```{r data, eval=TRUE}
#library(rjags)
library(tidyverse)
library(here)
#library(MCMCvis)

dogfish <- read_csv(here("processed-data","dogfish_prepped_data.csv"))

dogfishTest <- dogfish %>% 
  filter(lengthclass=="adult") %>% 
  group_by(year) %>% 
  mutate(num_obs = sum(numlengthclass),
         sd_obs = sd(numlengthclass)) %>% # this is standard deviation of different counts in a year, not of overall abundance over time
  select(year, num_obs, sd_obs) %>% 
  distinct()
# moving away from spiny dogfish because it is massively overdispersed and no single distribution will be able to produce values at low densities (1, 3, 10...) and at very high densities (5000, 8000, 10000) of dogfish; will eventually need a mixture model, and/or to totally disregard small values and assume everything under some threshold is basically equivalent

fluke <- read_csv(here("processed-data","fluke_prepped_data.csv"))

flukeTest <- fluke %>% 
  filter(lengthclass=="adult",
         year>=1972) %>% 
  group_by(year) %>% 
  summarise(num_obs = sum(numlengthclass))

```

Note that variables in stan cannot have periods.

Here's the stan script: 

```{stan, output.var="model1"}

data{

int<lower=1> len_t; // the number of observations

vector[len_t] y; // vector of observed number of individuals

// data inputs
real<lower=0> z0;
real<lower=0> sd0; 
} 

//transformed data{

//real z0; // starting population size

//z0 = round(y[1]);  

//}

parameters{ // define possible domain as all real numbers for now; can place bounds if desired

// these are either latent variables or will get priors later

//hyperparameters 
real r_hyper_mu;
real<lower=0> r_hyper_sigma;
real<lower=0> K_hyper_lower;
real<lower=K_hyper_lower> K_hyper_upper;
real<lower=0> sigma_obs_hyper_mean;
real<lower=0> sigma_obs_hyper_sd;
real<lower=0> sigma_process_hyper_lower;
real<lower=sigma_process_hyper_lower> sigma_process_hyper_upper; 

real r; // intrinsic pop growth rate
real<lower=K_hyper_lower, upper=K_hyper_upper> K; // carrying capacity
real<lower=0> sigma_obs; // SD for observation errors 
real<lower=sigma_process_hyper_lower, upper=sigma_process_hyper_upper> sigma_process; // SD for process errors 

vector<lower=0>[len_t] N; // population size--should be discrete (integer values), but Stan can't estimate latent discrete variables, so we're estimating it as continuous here 
real<lower=0> lambda0; // Ricker growth parameter at time step 1
real<lower=1e3, upper=1e7> gamma_shape0; // gamma parameter for process model at time step 1 - manually setting range
real<lower=1, upper=1e3> gamma_rate0; // gamma parameter for process model at time step 1 - manually setting range

} 

transformed parameters {
vector<lower=0>[len_t] lambda;
vector[len_t] gamma_shape; 
vector[len_t] gamma_rate;

lambda[1] = lambda0;
gamma_shape[1] = gamma_shape0;
gamma_rate[1] = gamma_rate0;

for(t in 2:len_t){
lambda[t] = N[t-1] * exp(r - r * N[t-1] / K); 
gamma_shape[t] = (lambda[t]^2) / (sigma_process^2);
gamma_rate[t] = lambda[t] / (sigma_process^2);
}
}

model{

// uniforms not strictly necessary if the bounds are appropriately declared in 
// the parameters block -- keeping for now as dists may change
K ~ uniform(K_hyper_lower, K_hyper_upper);
sigma_process ~ uniform(sigma_process_hyper_lower, sigma_process_hyper_upper);

//K_hyper_upper ~ normal(0, 1000);
//sigma_process_hyper_upper ~ normal(0, 1000);
r ~ normal(r_hyper_mu, r_hyper_sigma);
sigma_obs ~ normal(sigma_obs_hyper_mean, sigma_obs_hyper_sd);

// define initial values of time-varying latent variables 
N[1] ~ gamma((z0^2/sd0^2),(z0/sd0^2));
lambda0 ~ gamma((z0^2/sd0^2),(z0/sd0^2));
gamma_shape0 ~ uniform(1e3, 1e7);
gamma_rate0 ~ uniform(1, 1000);

//define later values of N (other quantities are defined, not estimated, after the first value)
N[2:len_t] ~ gamma(gamma_shape[2:len_t], gamma_rate[2:len_t]); 

// observation model
y ~ normal(N, sigma_obs); 
}

```

And model implementation from R:

```{r model1, echo=FALSE, results='hide', refresh=0}
warmups <- 1000

total_iterations <- 20000

max_treedepth <-  10

n_chains <-  4

n_cores <- 1

# starting values from real data 
dataStan1 <- list(len_t=nrow(flukeTest), 
                  y=as.double(flukeTest$num_obs), 
                  z0=round(mean(flukeTest$num_obs[1])),
                  sd0=sd(flukeTest$num_obs)
)

# starting values for parameters, to initialize chains (all drawn from distributions... eventually need to set.seed) 
initStan1 <- list()
for(i in 1:n_chains) {
  sigma_obs_hyper_mean_init <- rpois(1, dataStan1$z0)
  sigma_obs_hyper_sd_init <-rnorm(1, mean=100, sd=10)
  sigma_process_hyper_lower_init <- runif(1, min=0, max=10)
  sigma_process_hyper_upper_init <- runif(1, min=10, max=50)
  r_hyper_mu_init <- rnorm(1, mean=1, sd=1)
  r_hyper_sigma_init <- rnorm(1, mean=1, sd=0.5)
  K_hyper_lower_init <- rnorm(1, mean=100, sd=10)
  K_hyper_upper_init <- rnorm(1, 10000, sd=1000)
  sdoinit <- rnorm(1, mean=sigma_obs_hyper_mean_init,
                   sd=sigma_obs_hyper_sd_init)
  sdpinit <- runif(1, min=sigma_process_hyper_lower_init,
                   max=sigma_process_hyper_upper_init)
  rinit <- rnorm(1, mean=r_hyper_mu_init,
                 sd=r_hyper_sigma_init)
  Kinit <- runif(1, min=K_hyper_lower_init,
                 max=K_hyper_upper_init)
  
  initStan1[[i]] <- list(
    sigma_obs = sdoinit, 
    sigma_process=sdpinit, 
    sigma_obs_hyper_mean=sigma_obs_hyper_mean_init,  
    sigma_obs_hyper_sd=sigma_obs_hyper_sd_init,
    sigma_process_hyper_lower=sigma_process_hyper_lower_init, 
    sigma_process_hyper_upper=sigma_process_hyper_upper_init, 
    r_hyper_mu=r_hyper_mu_init, 
    r_hyper_sigma=r_hyper_sigma_init,
    K_hyper_lower=K_hyper_lower_init,
    K_hyper_upper=K_hyper_upper_init,
    r=rinit, 
    K=Kinit
  )
}

model1_fit <- # stan(file = here::here("R","model1.stan"),
  sampling(model1,
           data = dataStan1,
           chains = n_chains,
           warmup = warmups,
           iter = total_iterations,
           cores = n_cores,
           refresh = 250,
           init = initStan1,
           control = list(max_treedepth = max_treedepth,
                          adapt_delta = 0.95))
```

Evaluating the model:

```{r model1 eval}
summary(model1_fit)
plot(model1_fit)
rstanarm::launch_shinystan(model1_fit)

```