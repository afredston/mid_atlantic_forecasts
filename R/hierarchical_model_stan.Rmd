---
title: "Dynamic range model in Stan"
author: "Alexa Fredston and Malin Pinsky"
date: "begun November 2020"
output: html_document
---

Useful sources for Bayesian population models and Bayesian implementation in R that we referenced while building this script: 

* https://github.com/DanOvando/learn-stan 
* https://arxiv.org/src/2002.02001v1/anc/Appendix_S1.pdf p. 72
* https://cchecastaldo.github.io/BayesianShortCourse/Syllabus.html

```{r packages}
library(rstan)
library(rstanarm)
library(tidybayes)
library(bayesplot)
```


```{r, eval=TRUE}
#library(rjags)
library(tidyverse)
library(here)
#library(MCMCvis)

dogfish <- read_csv(here("processed-data","dogfish_prepped_data.csv"))

dogfishTest <- dogfish %>% 
  filter(lengthclass=="adult") %>% 
  group_by(year) %>% 
  summarise(num_obs = sum(numlengthclass)) 

```

Note that variables in stan cannot have periods.

Here's the stan script: 

```{stan, output.var="model1"}

data{

int len_t; // the number of observations

vector[len_t] y; // vector of observed number of individuals

// parameters for priors
real r_hyper_mu;
real r_hyper_sigma;
real K_hyper_lower;
real K_hyper_upper;
real sigma_obs_hyper_lower;
real sigma_obs_hyper_upper;
real sigma_process_hyper_lower;
real sigma_process_hyper_upper; 
real z0;

} 

//transformed data{

//real z0; // starting population size

//z0 = round(y[1]);  

//}

parameters{ // define possible domain as all real numbers for now; can place bounds if desired

real r; // intrinsic pop growth rate
real K; // carrying capacity
real sigma_obs; // SD for observation errors, dnorm
real sigma_process; // SD for process errors, negbin

} 

transformed parameters{

vector[len_t] p; // dnegbin parameter
vector[len_t] lambda; // Ricker growth parameter 

p[1] = sigma_process / (sigma_process + z0); 

for(t in 2:len_t) {
lambda[t] = N[t-1] * exp(r - r * N[t-1] / K); // depends on N which isn't defined yet, but when I moved up N it said integers can't be defined in a parameters block. 
p[t] = sigma_process / (sigma_process + lambda[t]); // error that it cannot divide real / vector
}


}

model{
int N[len_t]; // N, set this up as a 1D array of integers, not a vector, for the negative binomial distribution; tried to specify that it must be non-negative but it caused a syntax error, revisit this. 

// define distributions for priors 
r ~ normal(r_hyper_mu, r_hyper_sigma);
K ~ uniform(K_hyper_lower, K_hyper_upper);
sigma_obs ~ uniform(sigma_obs_hyper_lower, sigma_obs_hyper_upper);
sigma_process ~ uniform(sigma_process_hyper_lower, sigma_process_hyper_upper);

// process model; note that Stan allows vectorization of operations, so these aren't indexed anymore. not sure if the first time step specifications will work for p[1]...
N ~ neg_binomial(p, sigma_process)

// observation model
y ~ normal(N, sigma_obs)

//for(t in 2:len_t) { // remaining timesteps

//lambda[t] = N[t-1] * exp(r - r * N[t-1] / K);  // Ricker growth 
//p[t] = sigma_process / (sigma_process + lambda[t]); // convert to dnegbin parameter
// N[t] ~ neg_binomial(p[t], sigma_process); // process error
// this is throwing an error "No matches for:   real ~ neg_binomial(real, real)"
//}

// observation model
//for(t in 1:len_t){
//y[t] ~ normal(N[t],sigma_obs);
//}



}

generated quantities{
vector[len_t] t;




}

```

And model implementation from R:

```{r model1}
warmups <- 1000

total_iterations <- 2000

max_treedepth <-  10

n_chains <-  4

n_cores <- 1

dataStan1 <- list(len_t=nrow(dogfishTest), 
                 y=as.double(dogfishTest$num_obs), 
                 z0=round(mean(dogfishTest$num_obs[1])), # could also create this inside the stan model, not sure which is better
                 sigma_obs_hyper_lower=0.1, sigma_obs_hyper_upper=10000,
                 sigma_process_hyper_lower=0, sigma_process_hyper_upper=50,
                 r_hyper_mu=1, r_hyper_sigma=1,
                 K_hyper_lower=1, K_hyper_upper=100000)

initStan1 <- list()
for(i in 1:n_chains) {
  sdoinit <- runif(1, min=dataStan1$sigma_obs_hyper_lower,
                   max=dataStan1$sigma_obs_hyper_upper)
  sdpinit <- runif(1, min=dataStan1$sigma_process_hyper_lower,
                   max=dataStan1$sigma_process_hyper_upper)
  rinit <- rnorm(1, mean=dataStan1$r_hyper_mu,
                   sd=dataStan1$r_hyper_sigma)
  Kinit <- runif(1, min=dataStan1$K_hyper_lower,
                   max=dataStan1$K_hyper_upper)
  Ninit <- numeric(dataStan1$len_t)
  Ninit[1] <- rpois(1, dataStan1$z0)
  for(t in 2:dataStan1$len_t) {
    Ninit[t] <-rpois(1, Ninit[t-1])
  }
  initStan1[[i]] <- list(sigma_obs = sdoinit, sigma_process=sdpinit, r=rinit, K=Kinit, N=Ninit)
}

model1_fit <- stan(file = here::here("scripts","model1.stan"),
                 data = data,
                 chains = n_chains,
                 warmup = warmups,
                 iter = total_iterations,
                 cores = n_cores,
                 refresh = 250,
                 init = initStan1,
                 control = list(max_treedepth = max_treedepth,
                                adapt_delta = 0.95))
```


