---
title: "Dynamic range model in Stan"
author: "Alexa Fredston and Malin Pinsky"
date: "begun November 2020"
output: html_document
---

Useful sources for Bayesian population models and Bayesian implementation in R that we referenced while building this script: 

* https://github.com/DanOvando/learn-stan 
* https://arxiv.org/src/2002.02001v1/anc/Appendix_S1.pdf p. 72
* https://cchecastaldo.github.io/BayesianShortCourse/Syllabus.html

```{r packages}
library(rstan)
library(rstanarm)
library(tidybayes)
library(bayesplot)
```


```{r, eval=TRUE}
#library(rjags)
library(tidyverse)
library(here)
#library(MCMCvis)

dogfish <- read_csv(here("processed-data","dogfish_prepped_data.csv"))

dogfishTest <- dogfish %>% 
  filter(lengthclass=="adult") %>% 
  group_by(year) %>% 
  summarise(obsN = sum(numlengthclass)) 

```

Note that variables in stan cannot have periods.

Here's the stan script: 

```{stan, output.var="model1"}

data{

int lenT; // the number of observations

vector[lenT] y; // vector of observed number of individuals

// parameters for priors
real rHyperMu;
real rHyperSigma;
real KHyperLower;
real KHyperUpper;
real sigmaObsHyperLower;
real sigmaObsHyperUpper;
real sigmaProcessHyperLower;
real sigmaProcessHyperUpper; 
real z0;

} 

//transformed data{

//real z0; // starting population size

//z0 = round(y[1]); // this was previously wrapped in mean() which threw a stan error

//}

parameters{ // define possible domain as all real numbers for now; can place bounds if desired

real r; // intrinsic pop growth rate
real K; // carrying capacity
real sigmaObs; // SD for observation errors, dnorm
real sigmaProcess; // SD for process errors, negbin

} 

transformed parameters{

vector[lenT] N; // N, latent variable we are trying to estimate--do I need to initialize this? and if so, is this the right place? same question for p

vector[lenT] p; // dnegbin parameter

p[1] = sigmaProcess / (sigmaProcess + z0);

}

model{

// define distributions for priors
r ~ normal(rHyperMu, rHyperSigma);
K ~ uniform(KHyperLower, KHyperUpper);
sigmaObs ~ uniform(sigmaObsHyperLower, sigmaObsHyperUpper);
sigmaProcess ~ uniform(sigmaProcessHyperLower, sigmaProcessHyperUpper);

N[1] ~ neg_binomial(p[1], sigmaProcess); // first time step based on known z0

for(t in 2:lenT) { // remaining timesteps

lambda[t] = N[t-1] * exp(r - r * N[t-1] / K);  // Ricker growth 
p[t] = sigmaProcess/(sigmaProcess+lambda[t]); // convert to dnegbin parameter
N[t] ~ neg_binomial(p[t], sigmaProcess); // process error
// this is throwing an error "No matches for:   real ~ neg_binomial(real, real)"
}

// observation model
for(t in 1:lenT){
y[t] ~ normal(N[t],sigmaObs);
}



}

```

And model implementation from R:

```{r model1}
warmups <- 1000

total_iterations <- 2000

max_treedepth <-  10

n_chains <-  4

n_cores <- 1

dataStan1 <- list(lenT=nrow(dogfishTest), 
                 y=as.double(dogfishTest$obsN), 
                 z0=round(mean(dogfishTest$obsN[1])), # could also create this inside the stan model, not sure which is better
                 sigmaObsHyperLower=0.1, sigmaObsHyperUpper=10000,
                 sigmaProcessHyperLower=0, sigmaProcessHyperUpper=50,
                 rHyperMu=1, rHyperSigma=1,
                 KHyperLower=1, KHyperUpper=100000)

initStan1 <- list()
for(i in 1:n_chains) {
  sdoinit <- runif(1, min=dataStan1$sigmaObsHyperLower,
                   max=dataStan1$sigmaObsHyperUpper)
  sdpinit <- runif(1, min=dataStan1$sigmaProcessHyperLower,
                   max=dataStan1$sigmaProcessHyperUpper)
  rinit <- rnorm(1, mean=dataStan1$rHyperMu,
                   sd=dataStan1$rHyperSigma)
  Kinit <- runif(1, min=dataStan1$KHyperLower,
                   max=dataStan1$KHyperUpper)
  Ninit <- numeric(dataStan1$lenT)
  Ninit[1] <- rpois(1, dataStan1$z0)
  for(t in 2:dataStan1$lenT) {
    Ninit[t] <-rpois(1, Ninit[t-1])
  }
  initStan1[[i]] <- list(sigmaObs = sdoinit, sigmaProcess=sdpinit, r=rinit, K=Kinit, N=Ninit)
}

model1_fit <- stan(file = here::here("scripts","model1.stan"),
                 data = data,
                 chains = n_chains,
                 warmup = warmups,
                 iter = total_iterations,
                 cores = n_cores,
                 refresh = 250,
                 init = initStan1,
                 control = list(max_treedepth = max_treedepth,
                                adapt_delta = 0.95))
```


